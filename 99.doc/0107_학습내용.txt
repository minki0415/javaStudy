[학습노트]

1. java 프로그램 필수 학습 내용
	1) 기초 문법
		- 개발 및 호출 문법
		- package / import / class / 변수 / 생성자 / 메소드
		- class 또는 method / stack / heap
		- 클래스 간의 변수, 메소드 호출 방식 익숙해지기
		- 좋은 구조 : pattern
		- 클린코드 
			개발할 때 부터 좋은 코드 개발 방식
		- 리펙토링 
			만들어져 있는 것을 로직 변경없이 코드를 개선
		- 객체 활용에 대한 코드 이해
		
		** effective java(이펙티브 자바) / 조슈아 블로크 : 나중에 읽어보기
		
	2) 예외처리(exception handling)
		- 실행 시 발생 가능한 경미한 에러가 다수 존재
		- 경미한 에러를 코드로 사전에 방지하는 기술
		
	3) 상속과 다형성 
	 
	4) java.util package 에서 제공하는 데이터(자료) 활용 방식이 다양한 자료구조 클래스들 학습
	
	
	
2. 예외(exception)
	1) 처리 가능한 경미한 에러
	2) 필요성
		- 절대 이슈가 생겨도 프로그램 실행을 멈춰서는 안된다. 
		- 문제 발생 시 유연하게 처리하고 정상 실행 유지
	3) 예외 처리 문법
		- exception handling 문법
		
		1단계 : try~catch
		- try{
				실제 로직
				(단, 문제(예외)가 발생할수도 안할수도 있는 로직
		  }catch(발생한 예외타입 변수명){
		  		발생한 문제 처리하는 블록
		  }
		  
		  
		2단계 : try~catch~finally
		- try(1) ~ catch(1~여러개) ~ finally(0 or 1)
		- try{
				실제 로직
				(단, 문제(예외)가 발생할수도 안할수도 있는 로직
		  }catch(발생한 예외타입 변수명){
		  		발생한 문제 처리하는 블록
		  }finally{
		  		예외 발생 여부와 무관하게 무조건 실행되는 블록
		  }
		  
		 3단계 : API에서 제공되는 일부 메소드들 처럼 사용자 정의 메소드 body에서도
		 		상황에 따라 에외 객체 자체를 생성해서 호출한 곳으로 처리를 위임
		 		new 예외객체 생성 / throws로 메소드 선언구에서 던짐
		 		Class.forName()처럼 예외 던지면 호출한 우리 코드에서 try~catch 처리한 것 처럼
		 		사용자가 생성한 예외 객체도 호출한 코드에서 try~catch 처리
		 		
		  4단계 : Exception 클래스 직접 개발
		  		 사용자 정의 예외 클래스도 많음
		  		 Spring 등에서도 다수로 제공 
		  		 가령 id 중복된 경우 Id중복예외.java 라는 이름으로 예외 클래스를 개발 
		
	4) 예외 종류
		(1) 컴파일 예외
			- 예외 처리 문장 필수
			- 미처리시 컴파일 자체가 불가
			- 예시 : 
				로딩하고자 하는 byte code가 없을수도 있는 큰 이슈인
				ClassNotFoundException은 컴파일 예외이다.
			
		(2) 실행 예외
			- 컴파일 무조건 ok
			- 실행 시 발생
			- 부모 클래스 중에 java.lang.RuntimeException 존재
				예시 : RuntimeException의 상속 구조 (API)
				Class RuntimeException
					java.lang.Object
						java.lang.Throwable
							java.lang.Exception
								java.lang.RuntimeException
			- 해결책
				1. 값을 수정
				2. try ~ catch로도 처리는 가능
			- 예시 : 
				배열의 범위에 어긋나는 로직은 배열의 index 표현 즉, 실행 예외
		
		
		
3. 상속과 다형성

	1) 상속
		- extends 가 없는 클래스들은 무조건 extends Object 코드 자동 적용
		- 생성자 없는 클래스는 컴파일 시점에 기본생성자 자동 생성
		- println() 참조변수 출력 시 자동으로 toString() 호출
		
		
	 	(1) 조상(부모) 클래스 : 하위(자식) 클래스 관계
			- 상속시에 멤버변수와 메소드들은 하위 클래스에 상속
			- 장점
				복사, 붙여넣기가 아니라 코드 자체를 공유
				개발 속도 향상, 기업관점에서는 비용 절감
				
			- 참고
				class 내부의 구성요소
					- 멤버변수, 생성자, 메소드, static{}
					- 변수와 메소드만 상속
					
				단, 메소드 로직 수정(재정의, overriding, override)
					java.lang.Object root
						보유 메소드는 11개
						하위 모든 클래스는 11개를 상속
							단, toString() 재정의 
		
		
		(2) 상속 문법
			class 자식클래스명 extends 부모클래스명{
				상속받는 변수와 메소드
					- 재정의
					- jdk 1.5 부터 추가된 애노테이션
						@Override
						- 재정의 하는 메소드에 선언 권장
						- 표기는 옵션
				새롭게 선언하는 변수와 메소드
			}
		
		
		
		(3) 자식객체 생성시
			데이터를 공유(변수 상속)하는 부모 클래스 존재
			변수를 상속받은 자식 클래스
			
			//? 변수가 사용 가능하게 메모리에 생성 = 객체 생성 
			Child 객체 생성시 상속받은 변수들도 메모리에 생성
			Child 객체 생성 요청 시 Parent 객체도 생성 되어야 함 
			
			생성 순서
			Child c = new Child();
			생성순서? Parent 객체 먼저 생성? Child 먼저 생성?
	
	2) 다형성
		(1) 많은 타입의 형태를 보유할 수 있는 메커니즘
		(2) 전제조건
			- 상속 관계상에서만 다형성 적용
		(3) 예시
			int i = "2"; 불가
			String s = 2 ; 불가
			String s = new Person(); 불가(상속 관계가 아니기 때문에 불가)
			
			상속관계
			상위타입 변수 = 자식 객체
				Parent p = new Child();
		
		(4) 형변환
			1. 필요성 
				- 코드의 재사용성 강화
				- 상위타입의 변수는 절대 하위 타입의 멤버들 호출 불가능
				- API상에는 이미 재사용성을 고려해서 Object 타입을 parameter 또는 반환 타입으로 무수히 많이 사용됨
				
			2. 문법
				- 다운캐스팅(명시적으로 코드로 형변환)
					하위타입 변수 = (하위타입) 상위타입변수;
				
				- 업캐스팅(자동형변환)
					상위타입 변수 = 자식타입;
				
		(5) O X 퀴즈
			class A extends object{}
			class B extends A{}
			class C extends B{}
			class D extends A{}
			
			B,C는 D와 전혀 관계 없음
			
			Object o = new Object(); O
			= new A();	O
			= new B();	O
			= new C();	O
			= new D();	O
		
			A a = new Object(); X
			= new A();	O
			= new B();	O
			= new C();	O
			= new D();	O

			B a = new Object(); X
			= new A();	X
			= new B();	O
			= new C();	O
			= new D();	X

			D a = new Object(); X
			= new A();	X
			= new B();	X
			= new C();	X
			= new D();	O		
			
			System.out.println(int / String / Child / A / B / ... 사용자 정의 모든 참조 다 가능)
			API 개발자는 이 모든 타입을 어떻게 prameter로 허용
			- public void println(int v){}
			- public void println(float v){}
			- public void println(String v){}
			- public void println(Object v){} 최상위 타입 따라서 모든 참조 타입들 출력
			
			
			
4. 키워드
	1) this : 자신 객체를 참조하는 키워드
		this. : 객체 내의 멤버들 호출
		this([..]) : 동일한 클래스의 parameter가 일치하는 다른 생성자 호출 메소드
		
	2) super : 부모를 의미하는 키워드
		super. : 부모의 멤버들 호출
			- super.메소드명([..]) : 메소드 재정의로 간주
		super([..]) : 부모 클래스의 parameter가 생성자 호출 메소드
	
	
	
======================================
1월 7일 금요일

1. project명 
	step06_OOP
		step04.test package 활용
		
2. 개발 구조
	1. java 클래스 코드
		Person.java - 상위 클래스
			name/age
		Employee.java - Person 상속
			dept(부서명)
		Customer.java - Person 상속
			grade(등급)
		
		ShopAdmin.java
			- main()
			- 메소드
				1. ? publicData()
					- Person[] 배열에 고객 한명/ 직원 한명 저장
					- 배열 반환 
					
				2. print(?)
					- 배열을 받아서 고객 grade(등급)만 출력
					
					
					
